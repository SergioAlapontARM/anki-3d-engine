// Copyright (C) 2009-2022, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

ANKI_SPECIALIZATION_CONSTANT_U32(kZSplitCount, 0u);
ANKI_SPECIALIZATION_CONSTANT_U32(kFinalZSplit, 1u);

#pragma anki start vert
#include <AnKi/Shaders/QuadVert.glsl>
#pragma anki end

#pragma anki start frag

#include <AnKi/Shaders/Functions.glsl>

layout(location = 0) in Vec2 in_uv;
layout(location = 0) out ANKI_RP Vec4 out_color;

layout(set = 0, binding = 0) uniform sampler u_nearestAnyClampSampler;
layout(set = 0, binding = 1) uniform sampler u_linearAnyClampSampler;
layout(set = 0, binding = 2) uniform texture2D u_depthRt;
layout(set = 0, binding = 3) uniform texture3D u_fogVolume;

layout(push_constant, std140, row_major) uniform b_pc
{
	Vec2 u_padding;
	F32 u_near;
	F32 u_far;
};

void main()
{
	Vec3 uvw;

	// Compute W coordinate
	const F32 depth = textureLod(u_depthRt, u_nearestAnyClampSampler, in_uv, 0.0).r;
	const F32 linearDepth = linearizeDepth(depth, u_near, u_far);
	uvw.z = linearDepth * (F32(kZSplitCount) / F32(kFinalZSplit + 1u));

	// Compute UV coordinates
	uvw.xy = in_uv;

	// Read the volume
	const ANKI_RP Vec4 fogVals = textureLod(u_fogVolume, u_linearAnyClampSampler, uvw, 0.0);
	const ANKI_RP Vec3 inScattering = fogVals.rgb;
	const ANKI_RP F32 transmittance = fogVals.a;

	// Apply the fog
	out_color = Vec4(inScattering, transmittance);
}

#pragma anki end
